# Church numerals
cons Z
cons S(n)

# Erasure and Duplication
cons Erase                   deriving Erase
cons Dup(out1, out2) . in    deriving Erase
rule dupDup: Dup(a, b) . Dup(c, d) = a . c, b . d

# Example: Manual dup and erase rules (instead of deriving)
rule eraseZ: Erase . Z = ()
rule eraseS: Erase . S(x) = Erase . x
rule dupZ: Z . Dup(a, b) = a . Z, b . Z
rule dupS: S(x) . Dup(a, b) = x . Dup(sa, sb), a . S(sa), b . S(sb)

# Addition
cons Add(y, res) . x         deriving Erase, Dup
rule addZ: Add(y, r) . Z = y . r
rule addS: Add(y, r) . S(x) = Add(S(y), r) . x

# Multiplication
cons Mult(y, res) . x        deriving Erase, Dup
rule multZ: Mult(y, r) . Z = r . Z, y . Erase
rule multS: Mult(y, r) . S(x) = x . Mult(a, Add(b, r)), y . Dup (a, b)

# Example: Computations on church numerals
data y . S(S(S(S(S(Z))))),
     x . S(S(S(Z))),
     Add(y, example_3_plus_5) . x
data Mult(2'c, example_3_times_2) . 3'c

# Lists
cons Nil                     deriving Erase, Dup
cons Cons(head, tail) . l    deriving Erase, Dup

cons Length(res) . list      deriving Erase, Dup
rule lengthNil: Length(res) . Nil = res . Z
rule lengthCons: Length(res) . Cons(x, xs) = res . S(lxs), xs . Length(lxs), x . Erase

cons Map(fin, fout, res) . l deriving Erase, Dup
rule MapNil: Map(fin, fout, res) . Nil = res . Nil, fin . Erase, fout.Erase
rule MapCons: Map(fin, fout, res) . Cons(x, xs) = res . Cons(fouta, xsm), Map(finb, foutb, xsm) . xs, fin . Dup(fina, finb), fout . Dup(fouta, foutb), fina . x

# Example: List operations
data l0 . Cons(1'c, Cons(2'c, Cons(3'c, Nil))),
     l0 . Dup(l0a, l0b),
     Length(l0_length) . l0a,
     #fout . S(fin),
     fin . Add(2'c, fout),
     Map(fin, fout, l0_mapped) . l0b
