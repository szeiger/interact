# Church numerals
cons Z
cons S(n)

# Erasure and Duplication
# def erase(_)
# def dup(_): (a, b)
#   | dup(_) = (c, d) => (c, d)

# Addition
def add(_, y): r
  | Z => y
  | S(x) => add(x, S(y))

# Separate reductions
#match add(Z, y) => y
#match add(S(x), y) => add(x, S(y))

#match erase(Z) => ()
#match erase(S(x)) => erase(x)
#match dup(Z) = (a, b) => a = Z, b = Z
#match dup(S(x)) = (a, b) => (sa, sb) = dup(x), s = S(sa), b = S(sb)
#match dup(dup(_) = (c, d)) = (a, b) => (c, d)
#match S(x) = S(y) => x = y

# Multiplication
def mult(_, y): r
#  | Z => erase(y), Z
#  | S(x) => (y1, y2) = dup(y), add(mult(x, y1), y2)

match mult(Z, y) => erase(y), Z
match mult(S(x), y) => (y1, y2) = dup(y), add(mult(x, y1), y2)

# Example: Computations on church numerals
let y = 5'c,
    x = 3'c,
    example_3_plus_5 = add(x, y)

let example_3_times_2 = mult(3'c, 2'c)

# Lists
cons Nil
cons Cons(head, tail): l

def length(list): r
  | Nil => Z
  | Cons(x, xs) => erase(x) , S(length(xs))

def map(list, fi, fo): r
  | Nil => erase(fi), erase(fo), Nil
  | Cons(x, xs) => (x, fi2) = dup(fi),
                   (fo1, fo2) = dup(fo),
                   Cons(fo1, map(xs, fi2, fo2))

# Example: List operations
let l0 = Cons(1'c, Cons(2'c, Cons(3'c, Nil))),
    (l0a, l0b) = dup(l0),
    l0_length = length(l0a),
    fout = add(fin, 2'c),
    l0_mapped = map(l0b, fin, fout)

# Explicit lambdas
cons Lambda(in, out)
def apply(l, in): out
  | Lambda(i, o) => in = i, o

# Example: List mapping with lambdas
def map2(l, f): r
  | Nil => erase(f), Nil
  | Cons(x, xs) => (f1, f2) = dup(f),
                   Cons(apply(f1, x), map2(xs, f2))

let l0 = 1'c :: 2'c :: 3'c :: Nil,
    fout = add(fin, 2'c),
    f = Lambda(fin, fout),
    l0_mapped_lambda = map2(l0, f)
